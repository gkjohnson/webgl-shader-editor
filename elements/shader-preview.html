<dom-module id="shader-preview">
    <template>
        <style type="text/css">
            #container {
                display: flex;
                flex-direction: column;
                width: 100%;
                height: 100%;
            }

            #target {
                width: 100%;
                image-rendering: pixelated;
            }

            image-magnifier {
                visibility: hidden;
            }

            #debug-list {
                display: flex;
                flex-wrap: wrap;
                width: 100%;
                overflow-y: auto;
            }

            #debug-list:not([show]) {
                display: none;
            }

            #debug-list .shader {
                flex: 1;
                min-width: 100px;
                max-width: 200px;
                transition: opacity .25s ease;
            }

            #debug-list:hover .shader {
                opacity: 0.25;
            }

            #debug-list:hover .shader:hover {
                opacity: 1;
            }

            #debug-list .name {
                text-align: center;
                font-weight: 900;
                font-size: 14px;
                font-style: italic;

                opacity: 0.75;
            }

            #local-variables-list {
                padding: 10px;
            }

            #local-variables-list .data {
                display: flex;
                padding: 5px 10px;
            }

            #local-variables-list .data span {
                flex: 1;
                font-size: 14px;
            }

            #local-variables-list .data .name {
                flex: 2;
            }


            #debug-list .shader img {
                width: 100%;
            }

            ::-webkit-scrollbar
            {
                width: 5px;
                position: absolute;
            }

            ::-webkit-scrollbar-thumb
            {
                border-radius: 5px;
                background-color: rgba(255,255,255,0.2);
            }
        </style>
        
        <image-magnifier
            scale="20"
            src="[[_primaryImageSrc]]"
        ></image-magnifier>

        <div id="container">
            <zoomable-image
                id="target"
                src="[[_primaryImageSrc]]"
                max-scale="10"
                on-mouseenter="_imageMouseEnterHandler"
                on-mousemove="_imageMouseMoveHandler"
                on-mouseleave="_imageMouseLeaveHandler"
                clamp
            ></zoomable-image>
            
            <div id="debug-list" show$="[[!_exists(_localVariables)]]">
                <template is="dom-repeat" items="[[_images]]">
                    <div
                        class="shader"
                        active$="[[_equals(index,_activeImage)]]"
                        on-click="_debugImageClickHandler"
                    >
                        <div class="name">[[item.type]] [[item.name]]</div>
                        <img src$="[[item.src]]" />
                    </div>
                </template>
            </div>

            <div id="local-variables-list" show$="[[_exists(_localVariables)]]">
                <template is="dom-repeat" items="[[_localVariables]]">
                    <div class="data">
                        <span class="name">[[item.type]] [[item.name]]</span>
                        <span>[[item.data.0]]</span>
                        <span>[[item.data.1]]</span>
                        <span>[[item.data.2]]</span>
                        <span>[[item.data.3]]</span>
                    </div>
                </template>
            </div>
        </div>
    </template>
</dom-module>
<script type="text/javascript">
    class ShaderPreview extends Polymer.Element {
        static get is() { return 'shader-preview' }

        static get properties() {
            return {
                vertexShader: {
                    type: String,
                    value: '',
                    notify: true
                },

                fragmentShader: {
                    type: String,
                    value: '',
                    notify: true,
                },

                vertexErrors: {
                    type: Array,
                    value: null,
                    notify: true
                },

                fragmentErrors: {
                    type: Array,
                    value: null,
                    notify: true
                },

                _shaders: {
                    type: Array,
                    value: () => [],
                    computed: '_computeShaders(vertexShader, fragmentShader)'
                },

                _images: {
                    type: Array,
                    value: () => []
                },

                _activeImage: {
                    type: Number,
                    value: 0
                },

                _primaryImageSrc: {
                    type: String,
                    computed: '_computeImageSrc(_images.*, _activeImage)'
                },

                _localVariables: {
                    type: Array,
                    value: null
                }
            }
        }

        static get observers() {
            return [ '_shadersObserver(_shaders)' ]
        }

        // Lifecycle Functions
        ready() {
            super.ready()

            const scene = new THREE.Scene()
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
            renderer.setPixelRatio(window.devicePixelRatio)
            renderer.setSize(400, 400)
            renderer.setClearColor(0x000000, 0)

            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 50)
            camera.position.z = 10
            scene.add(camera)

            const material = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib["lights"]
            ]), lights: true })
            const sphere = new THREE.Mesh(new THREE.SphereGeometry( 5, 32, 32 ), material )
            scene.add( sphere );
            scene.add(new THREE.AmbientLight(0x222222))
            
            const dl = new THREE.DirectionalLight( 0xffffff, 0.5 );
            dl.position.x = 1;
            dl.position.y = 1;
            dl.position.z = 1;
            scene.add( dl );
            
            const target = this.shadowRoot.querySelector('#target')
            const orbit = new THREE.OrbitControls(camera, target)
            orbit.enableZoom = false
            orbit.addEventListener('change', () => this._render(true))
            target.addEventListener('mouseup', () => this._render())

            this._renderer = renderer
            this._scene = scene
            this._camera = camera
            this._material = material

            this._render()
        }

        // Utilities
        _equals(a,b) {
            return a === b
        }

        _exists(a) {
            return !!a
        }

        _getLogErrors(logs, lineOffset = 0) {
            return logs
                .replace(String.fromCharCode(0), '')
                .trim()
                .split('\n')
                .map(line => this._getLogError(line, lineOffset))
        }

        _getLogError(log, lineOffset = 0) {
            const regex = /^ERROR: ([^:]+):([^:]+)\s*:/
            const matches = log.match(regex)
            let row = 0
            let col = 0
            if(matches != null) {
                row = parseFloat(matches[2]) - lineOffset
                col = parseFloat(matches[1])

                row = row || 0
                col = col || 0
            }
            log = log.replace(regex, '').trim()            

            return { row, col, log }
        }

        // Private Functions
        _updateMaterialAndRender(vs, fs, checkforerrors) {
            if (!this._material) return

            this._material.vertexShader = vs
            this._material.fragmentShader = fs

            this._material.lights = true
            this._material.uniforms = THREE.UniformsUtils.merge([
                THREE.UniformsLib["lights"]
            ]);

            this._material.needsUpdate = true
            this._renderer.render(this._scene, this._camera)

            if (checkforerrors) this._checkForError()
        }

        _checkForError() {
            const diag = this._renderer.info.programs[0].diagnostics
            if (!diag || !diag.fragmentShader.log) {
                this.fragmentErrors = null
            } else {
                this.fragmentErrors = this._getLogErrors(diag.fragmentShader.log, diag.fragmentShader.prefix.split('\n').length)
            }

            if (!diag || !diag.vertexShader.log) {
                this.vertexErrors = null
            } else {
                this.vertexErrors = this._getLogErrors(diag.vertexShader.log, diag.vertexShader.prefix.split('\n').length)
            }
        }

        _render(activeOnly = false) {
            if (!this._renderer) return

            let arr = this._images

            // expand the array if necessary
            while (arr.length > this._shaders.length) this.pop('_images')
            while (arr.length < this._shaders.length) this.push('_images', {})

            // TODO: Do this over multiple frames
            let bail = false
            for (let i = 0; i < this._shaders.length; i ++) {
                if (activeOnly && i !== this._activeImage) continue

                const item = this._shaders[i]
                const vs = item.vertexShader
                const fs = item.fragmentShader

                const setpref = `_images.${i}`

                this.set(`${setpref}.name`, item.name)
                this.set(`${setpref}.type`, item.type)
                arr[i].img = arr[i].img || new Image()

                if (!bail) {
                    // TODO: We shouldn't have to call this if there are no
                    // material updates. Right now we're dirtying the material
                    // every frame for every pass, which is super slow
                    this._updateMaterialAndRender(vs, fs, i === 0)
                    this.set(`${setpref}.src`, this._renderer.domElement.toDataURL('image/png'))
                } else {
                    this.set(`${setpref}.src`, '')
                }

                arr[i].img.src = arr[i].src

                bail = this.fragmentErrors || this.vertexErrors
            }
        }

        // Event Handlers
        _imageMouseEnterHandler() {
            this.shadowRoot.querySelector('image-magnifier').style.visibility = 'visible'
        }

        _imageMouseMoveHandler(e) {
            const im = this.shadowRoot.querySelector('image-magnifier')

            im.style.top = e.pageY + 'px'
            im.style.left = (e.pageX - im.clientWidth) + 'px'

            im.xPixel = e.pixel.x
            im.yPixel = e.pixel.y

            const arr = []
            this._images.forEach(item => {
                const px = DebugShaders.readPixel(item.img, e.pixel.x, e.pixel.y)
                const data = DebugShaders.pixelToArray(px, item.type)
                arr.push({
                    type: item.type,
                    name: item.name,
                    data
                })
            })

            this._localVariables = arr
        }

        _imageMouseLeaveHandler() {
            this.shadowRoot.querySelector('image-magnifier').style.visibility = 'hidden'
            this._localVariables = null
        }

        _debugImageClickHandler(e) {
            this._activeImage = e.model.index
        }

        // Computed Variables
        _computeShaders(vs, fs) {
            const prim = {
                type: 'vec4',
                name: 'color',
                vertexShader: vs,
                fragmentShader: fs,
                line: 0
            }
            const arr = [prim].concat(DebugShaders.enumerate(vs, fs))

            return arr
        }

        _computeImageSrc(images, i) {
            return images.base[i] ? images.base[i].src : ''
        }

        // Observers
        _shadersObserver(shaders) {
            this._render()
        }
    }
 
    customElements.define(ShaderPreview.is, ShaderPreview)
</script>