<dom-module id="shader-preview">
    <template>
        <style type="text/css">
            /* Util Classes */
            ::-webkit-scrollbar
            {
                width: 5px;
                position: absolute;
            }

            ::-webkit-scrollbar-thumb
            {
                border-radius: 5px;
                background-color: rgba(255,255,255,0.2);
            }

            [hidden] {
                display: none !important;
            }

            #container {
                display: flex;
                flex-direction: column;
                width: 100%;
                height: 100%;
            }

            #target {
                width: 100%;
                image-rendering: pixelated;
            }

            image-magnifier {
                visibility: hidden;
                z-index: 1000;
            }

            /* Debug Shader Displays */
            #debug-list {
                display: flex;
                flex-wrap: wrap;
                width: 100%;
                overflow-y: auto;
            }

            #debug-list .shader {
                flex: 1;
                min-width: 100px;
                max-width: 200px;
                transition: opacity .25s ease;
            }

            #debug-list:hover .shader {
                opacity: 0.25;
            }

            #debug-list:hover .shader:hover {
                opacity: 1;
            }

            #debug-list .name {
                text-align: center;
                font-weight: 900;
                font-size: 14px;
                font-style: italic;

                white-space: pre;
                overflow: hidden;
                text-overflow: ellipsis;

                opacity: 0.75;
            }

            /* Local Variables Section */
            #local-variables-list {
                padding: 10px;
                overflow: hidden;
            }

            #local-variables-list .data {
                display: flex;
                padding: 5px 10px;
            }

            #local-variables-list .data span {
                flex: 1;
                font-size: 14px;
                font-weight: 900;
            }

            #local-variables-list .data .name {
                flex: 2;
                opacity: 0.75;
                white-space: pre;
                overflow: hidden;
                text-overflow: ellipsis;
                font-style: italic;
            }

            #debug-list .shader img {
                width: 100%;
            }

            .header {
                font-weight: bold;
                padding: 15px;
            }

            /* Header */
            #header {
                display: flex;
            }

            #header .name {
                flex: 1;
                font-weight: bold;
                padding: 5px;
                display: inline-block;
            }

            #header .shape {
                padding: 4px;
                opacity: 0.5;
                transition: opacity .25s ease;
            }

            #header .shape:hover {
                opacity: 1;
            }

            #header .shape:before {
                content: '';
                width:18px;
                height:18px;
                display: block;
            }

            #header .shape[shape="plane"]:before,
            #header .shape[shape="sphere"]:before {
                background: white;
            }
            
            #header .shape[shape="sphere"]:before {
                border-radius: 100px;
            }

            #header .shape[shape="plane"]:before {
                width: 16px;
                height: 16px;
                margin: 1px;
            }

            #header .shape[shape="cube"]:before {
                /*
                TODO: The cube image cannot properly be loaded
                with webpack at the moment
                */
                /*content: 'cube';*/
                background-image: url('../images/cube-icon.png');
                background-size: cover;

            }
        </style>
        
        <image-magnifier
            scale="20"
            src="[[_primaryImageSrc]]"
        ></image-magnifier>

        <div id="container">
            <div id="header">
                <span class="name">[[_getName(_images.*, _activeImage)]]</span>
                <span class="shape" on-click="_setShapeHandler" shape="cube" title="cube"></span>
                <span class="shape" on-click="_setShapeHandler" shape="sphere" title="sphere"></span>
                <span class="shape" on-click="_setShapeHandler" shape="plane" title="plane"></span>
            </div>
            <zoomable-image
                id="target"
                src="[[_primaryImageSrc]]"
                max-scale="10"
                on-mouseenter="_imageMouseEnterHandler"
                on-mousemove="_imageMouseMoveHandler"
                on-mouseleave="_imageMouseLeaveHandler"
                clamp
            ></zoomable-image>
            
            <div class="header">Local Fragment Shader Variables</div>
            <div id="debug-list" hidden$="[[_exists(_localVariables)]]">
                <template is="dom-repeat" items="[[_images]]">
                    <div
                        class="shader"
                        active$="[[_equals(index,_activeImage)]]"
                        on-click="_debugImageClickHandler"
                    >
                        <div class="name">[[item.type]] [[item.name]]</div>
                        <img src$="[[item.src]]" />
                    </div>
                </template>
            </div>

            <div id="local-variables-list" hidden$="[[!_exists(_localVariables)]]">
                <template is="dom-repeat" items="[[_localVariables]]">
                    <div class="data">
                        <span class="name">[[item.type]] [[item.name]]</span>
                        <span>[[item.data.0]]</span>
                        <span>[[item.data.1]]</span>
                        <span>[[item.data.2]]</span>
                        <span>[[item.data.3]]</span>
                    </div>
                </template>
            </div>
        </div>
    </template>
</dom-module>
<script type="text/javascript">
    // shader-preview Element
    // Element to preview, zoom in, and debug shader definitions
    class ShaderPreview extends Mixin(Polymer.Element, Debouncer) {
        static get is() { return 'shader-preview' }

        static get properties() {
            return {
                // vertex shader to preview
                vertexShader: {
                    type: String,
                    value: ''
                },

                // fragment shader to preview
                fragmentShader: {
                    type: String,
                    value: ''
                },

                // a map of "uniform name" : "texture path" to load
                // the application
                textures: {
                    type: Object,
                    value: () => { return {} },
                    observer: '_texturesObserver'
                },

                // vertex shader compilation errors
                vertexErrors: {
                    type: Array,
                    value: null,
                    notify: true
                },

                // fragment shader compilation errors
                fragmentErrors: {
                    type: Array,
                    value: null,
                    notify: true
                },

                // array of shaders to render, including the original
                // and debug shaders. The original shader is always in
                // index 0
                _shaders: {
                    type: Array,
                    value: () => [],
                    computed: '_computeShaders(vertexShader, fragmentShader)'
                },

                // the objects representing rendered images
                _images: {
                    type: Array,
                    value: () => []
                },

                // the index of the currently active image to render
                // in the primary display spot
                _activeImage: {
                    type: Number,
                    value: 0
                },

                // the source of the primary image
                _primaryImageSrc: {
                    type: String,
                    computed: '_computeImageSrc(_images.*, _activeImage)'
                },

                // the list of local variable definitions from hovering over
                // the image
                _localVariables: {
                    type: Array,
                    value: null
                },

                // the type of geometry to display
                _displayGeometry: {
                    type: String,
                    value: 'sphere',
                    observer: '_displayGeometryObserver'
                },

                // the textures that have been loaded
                _loadedTextures: {
                    type: Object,
                    value: () => { return {} }
                },

                // the target size to render to
                // TODO: Respect when this changes
                _renderSize: {
                    type: Number,
                    value: 400
                } 
            }
        }

        static get observers() {
            return [
                '_shadersObserver(_shaders)',
                '_deepLoadedTexturesObserver(_loadedTextures.*)'
            ]
        }

        /* Lifecycle Functions */
        ready() {
            super.ready()

            const scene = new THREE.Scene()
            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true })
            renderer.setPixelRatio(window.devicePixelRatio)
            renderer.setSize(this._renderSize, this._renderSize)
            renderer.setClearColor(0x000000, 0)

            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 50)
            camera.position.z = 10
            scene.add(camera)

            const meshes = {
                cube: new THREE.Mesh(new THREE.BoxGeometry( 5, 5, 5, 50, 50, 50 ), null ),
                plane: new THREE.Mesh(new THREE.PlaneGeometry( 5, 5, 100, 100 ), null ),
                sphere: new THREE.Mesh(new THREE.IcosahedronGeometry(5, 5), null),
            }
            scene.add( meshes[this._displayGeometry] );
            scene.add(new THREE.AmbientLight(0x222222))
            
            const dl = new THREE.DirectionalLight( 0xffffff, 0.5 );
            dl.position.x = 1;
            dl.position.y = 1;
            dl.position.z = 1;
            scene.add( dl );
            
            const target = this.shadowRoot.querySelector('#target')
            const orbit = new THREE.OrbitControls(camera, target)
            orbit.enableZoom = false
            orbit.enablePan = false
            orbit.enableKeys = false
            orbit.addEventListener('change', () => this._render(true))
            target.addEventListener('mouseup', () => this._render())

            this._renderer = renderer
            this._scene = scene
            this._camera = camera
            this._meshes = meshes

            this._render()
        }

        /* Utilities */
        _equals(a,b) { return a === b }

        _exists(a) { return !!a }

        // parses the log definition from THREE.js to extract
        // the line number and error
        _getLogError(log, lineOffset = 0) {
            const regex = /^ERROR: ([^:]+):([^:]+)\s*:/
            const matches = log.match(regex)
            let row = 0
            let col = 0
            if(matches != null) {
                row = parseFloat(matches[2]) - lineOffset
                col = parseFloat(matches[1])

                row = row || 0
                col = col || 0
            }
            log = log.replace(regex, '').trim()            

            return { row, col, log }
        }

        // parses a set of logs
        _getLogErrors(logs, lineOffset = 0) {
            return logs
                .replace(String.fromCharCode(0), '')
                .trim()
                .split('\n')
                .map(line => this._getLogError(line, lineOffset))
        }

        // create a new material
        _getMaterial() {
            const mat = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.merge([
                        THREE.UniformsLib["lights"],
                        { _negate_: { value: false } }
                    ]),
                lights: true,
                side: THREE.DoubleSide
            })
            return mat
        }

        // returns the name for the given image object index
        _getName(imgbase, index) {
            const img = imgbase.base[index]
            return img ? img.name : ''
        }

        /* Private Functions */
        _updateUniforms(mat) {
            for (let key in mat.uniforms) {
                if (mat.uniforms[key].type !== 't') continue

                if (!(key in this._loadedTextures)) {
                    delete mat.uniforms[key]
                }
            }

            for (let key in this._loadedTextures) {
                mat.uniforms[key] = {
                    type:   't',
                    value:  this._loadedTextures[key].texture,
                    texture: this._loadedTextures[key].texture
                }
            }

            const res = this._renderSize
            mat.uniforms.screenSize = { type: '4f', value: [res, res, 1 / res, 1 / res] }
        }

        // reads, parses, and assigns the errors to the error properties
        // for the given material
        _checkForError(mat) {
            const diag = mat.program.diagnostics

            if (!diag || !diag.fragmentShader.log) {
                this.fragmentErrors = null
            } else {
                this.fragmentErrors = this._getLogErrors(
                    diag.fragmentShader.log,
                    diag.fragmentShader.prefix.split('\n').length
                )
            }

            if (!diag || !diag.vertexShader.log) {
                this.vertexErrors = null
            } else {
                this.vertexErrors = this._getLogErrors(
                    diag.vertexShader.log,
                    diag.vertexShader.prefix.split('\n').length
                )
            }
        }

        // Renders all the images and updates the _images array with the new
        // image information
        // If `activeOnly` is true, then only the primary image will be rendered
        _render(activeOnly = false) {
            if (!this._renderer) return

            this.vertexErrors = null
            this.fragmentErrors = null

            // assign the new shaders to the images being rendered
            this._shaders.forEach((s, i) => {
                if (activeOnly && i !== this._activeImage) return
                    
                const fs = s.fragmentShader
                const vs = s.vertexShader

                const setpref = `_images.${i}`
                if (this.fragmentErrors || this.vertexErrors) {
                    this.set(`${setpref}.src`, '')
                } else {
                    const material = this._images[i].material
                    this._updateTextureUniforms(material)

                    this._meshes[this._displayGeometry].material = this._images[i].material
                    
                    this._images[i].material.uniforms._negate_.value = false
                    this._renderer.render(this._scene, this._camera)
                    this.set(`${setpref}.src`, this._renderer.domElement.toDataURL('image/png'))

                    this._images[i].material.uniforms._negate_.value = true
                    this._renderer.render(this._scene, this._camera)
                    this.set(`${setpref}.negsrc`, this._renderer.domElement.toDataURL('image/png'))

                    // only check for errors on the first go because thats
                    // the one that the user is writing
                    if (i === 0) this._checkForError(this._images[i].material)
                }

                this._images[i].img.src = this._images[i].src
                this._images[i].negimg.src = this._images[i].negsrc
            })
        }

        /* Event Handlers */
        // Mouse hover events for inspecting local variables
        _imageMouseEnterHandler() {
            this.shadowRoot.querySelector('image-magnifier').style.visibility = 'visible'
        }

        _imageMouseMoveHandler(e) {
            const im = this.shadowRoot.querySelector('image-magnifier')

            im.style.top = e.pageY + 'px'
            im.style.left = (e.pageX - im.clientWidth) + 'px'

            im.xPixel = e.pixel.x
            im.yPixel = e.pixel.y

            const arr = []
            this._images.forEach(item => {
                const px = DebugShaders.readPixel(item.img, e.pixel.x, e.pixel.y)
                const data = DebugShaders.pixelToArray(px, item.type)
                
                const negpx = DebugShaders.readPixel(item.negimg, e.pixel.x, e.pixel.y)
                const negdata = DebugShaders.pixelToArray(negpx, item.type)

                for(let i in data) data[i] = data[i] || -negdata[i]

                arr.push({
                    type: item.type,
                    name: item.name,
                    data
                })
            })

            this._localVariables = arr
        }

        _imageMouseLeaveHandler() {
            this.shadowRoot.querySelector('image-magnifier').style.visibility = 'hidden'
            this._localVariables = null
        }

        _debugImageClickHandler(e) {
            this._activeImage = e.model.index
        }

        _setShapeHandler(e) {
            this._displayGeometry = e.target.getAttribute('shape')
        }

        /* Computed Variables */
        _computeShaders(vs, fs) {
            const prim = {
                type: 'vec4',
                name: 'color',
                vertexShader: vs,
                fragmentShader: fs,
                line: 0
            }
            const arr = [prim].concat(DebugShaders.enumerate(vs, fs))

            return arr
        }

        _computeImageSrc(images, i) {
            return images.base[i] ? images.base[i].src : ''
        }

        /* Observers */
        _texturesObserver(textures) {
            for (let key in this._loadedTextures) {
                const removed = !(key in textures)
                const changed = !removed && this._loadedTextures[key].source !== textures[key] 

                if (removed || changed) {
                    this._loadedTextures[key].dispose()
                    this.set(`_loadedTextures.${key}`, undefined)
                }
            }

            for (let key in textures) {
                if (!(key in this._loadedTextures)) {
                    const thisKey = key
                    this.set(`_loadedTextures.${key}`, {
                        source: textures[key],
                        texture: new THREE.TextureLoader().load(
                            textures[key],

                            // // texture loaded callkback
                            // texture => this.set(`_loadedTextures.${thisKey}.texture`, texture),
                            
                            // // load percentage callback
                            // null,

                            // // error callback
                            // () => this.set(`_loadedTextures.${thisKey}`, undefined)
                        )
                    })
                }
            }
        }

        _deepLoadedTexturesObserver() {
            this.debounce('rerender', () => this._render(), 500)
        }

        _shadersObserver(shaders) {

            // expand or shorten the array if necessary
            while (this._images.length > this._shaders.length) {
                const item = this.pop('_images')
                item.material.dispose()
            }

            while (this._images.length < this._shaders.length) {
                this.push('_images', {
                    img: new Image(),
                    negimg: new Image(),
                    material: this._getMaterial(),
                    src: '',
                    negsrc: '',
                    name: '',
                    type: ''
                })
            }

            shaders.forEach((s, i) => {
                const item = this._images[i]
                const setpref = `_images.${i}`

                this.set(`${setpref}.name`, s.name)
                this.set(`${setpref}.type`, s.type)

                item.material.vertexShader = s.vertexShader
                item.material.fragmentShader = s.fragmentShader
                item.material.needsUpdate = true
            })

            this._render(true)
            this.debounce('rerender', () => this._render(), 500)
        }

        _displayGeometryObserver(newgeom, oldgeom) {
            if (!this._meshes) return

            this._scene.remove(this._meshes[oldgeom])
            this._scene.add(this._meshes[newgeom])

            this._render()
        }
    }
 
    customElements.define(ShaderPreview.is, ShaderPreview)
</script>